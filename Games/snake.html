<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Neon Snake — HTML/CSS/JS Only</title>
  <style>
    :root {
      --bg: #0b0f1a;
      --panel: #0f172a;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --accent: #22d3ee; /* cyan */
      --accent-2: #a78bfa; /* violet */
      --danger: #f43f5e; /* rose */
      --success: #34d399; /* green */
      --shadow: 0 10px 30px rgba(34,211,238,.25);
      --radius: 16px;
    }
    * { box-sizing: border-box }
    html, body { height: 100% }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text);
      background:
        radial-gradient(1000px 500px at 10% -10%, rgba(167, 139, 250, .25), transparent 60%),
        radial-gradient(1000px 500px at 110% 110%, rgba(34, 211, 238, .25), transparent 60%),
        var(--bg);
      display: grid;
      place-items: center;
      padding: 24px;
    }
    .game-wrap {
      width: min(96vw, 980px);
      display: grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 20px;
      align-items: start;
    }
    @media (max-width: 860px) {
      .game-wrap { grid-template-columns: 1fr; }
    }
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border: 1px solid rgba(148,163,184,.18);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(6px);
    }
    .board {
      position: relative;
      aspect-ratio: 1 / 1; /* Keep square */
      overflow: hidden;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background:
        linear-gradient(180deg, rgba(15,23,42,.9), rgba(2,6,23,.9)),
        repeating-linear-gradient(90deg, rgba(255,255,255,.03) 0 1px, transparent 1px 40px),
        repeating-linear-gradient(0deg, rgba(255,255,255,.03) 0 1px, transparent 1px 40px);
      border-radius: var(--radius);
      border: 1px solid rgba(148,163,184,.18);
    }
    .hud {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px 12px;
      padding: 14px 16px;
      align-items: center; 
    }
    .hud .title {
      grid-column: 1/-1;
      font-weight: 800;
      letter-spacing: .5px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .badge {
      font-size: 12px;
      color: var(--accent);
      padding: 2px 8px;
      border: 1px solid rgba(34,211,238,.4);
      border-radius: 999px;
    }
    .stat {
      background: rgba(2,6,23,.5);
      border: 1px solid rgba(148,163,184,.18);
      border-radius: 12px;
      padding: 10px 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-variant-numeric: tabular-nums;
    }
    .stat .label { color: var(--muted); font-size: 12px; }
    .stat .value { font-weight: 700; }

    .controls { padding: 12px 16px 16px; display: grid; gap: 12px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; }
    button, select, input[type="range"] { 
      appearance: none; border: none; outline: none; font: inherit; color: inherit;
    }
    .btn {
      padding: 10px 14px; border-radius: 12px; cursor: pointer; user-select: none;
      background: linear-gradient(180deg, rgba(34,211,238,.15), rgba(34,211,238,.08));
      border: 1px solid rgba(34,211,238,.45);
      box-shadow: 0 6px 20px rgba(34,211,238,.18) inset;
      transition: transform .08s ease, filter .2s ease;
    }
    .btn:hover { filter: brightness(1.05) }
    .btn:active { transform: translateY(1px) }
    .btn.secondary {
      background: linear-gradient(180deg, rgba(167,139,250,.15), rgba(167,139,250,.08));
      border: 1px solid rgba(167,139,250,.45);
      box-shadow: 0 6px 20px rgba(167,139,250,.18) inset;
    }
    .btn.danger {
      background: linear-gradient(180deg, rgba(244,63,94,.15), rgba(244,63,94,.08));
      border: 1px solid rgba(244,63,94,.45);
      box-shadow: 0 6px 20px rgba(244,63,94,.18) inset;
    }

    .settings { background: rgba(2,6,23,.5); border: 1px solid rgba(148,163,184,.18); border-radius: 12px; padding: 12px; }
    .settings .group { display: grid; gap: 8px; margin-bottom: 12px; }
    .settings label { font-size: 12px; color: var(--muted) }
    .settings .inline { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .select, .toggle { background: rgba(15,23,42,.7); border: 1px solid rgba(148,163,184,.25); border-radius: 10px; padding: 8px 10px; }
    .toggle { display: inline-flex; align-items: center; gap: 8px; cursor: pointer; }
    .toggle input { width: 18px; height: 18px; }

    .overlay { position: absolute; inset: 0; display: grid; place-items: center; background: rgba(2,6,23,.6); border-radius: var(--radius); opacity: 0; pointer-events: none; transition: opacity .2s ease; }
    .overlay.show { opacity: 1; pointer-events: auto; }
    .card {
      background: linear-gradient(180deg, rgba(15,23,42,.96), rgba(2,6,23,.96));
      border: 1px solid rgba(148,163,184,.28);
      padding: 24px; border-radius: 16px; text-align: center; width: min(90%, 420px);
      box-shadow: 0 20px 60px rgba(0,0,0,.45);
    }
    .card h2 { margin: 0 0 8px; font-size: 22px }
    .card p { margin: 0 0 16px; color: var(--muted) }

    /* On-screen d-pad for mobile */
    .dpad { position: absolute; inset: auto 10px 10px auto; display: grid; grid-template-columns: repeat(3, 52px); gap: 8px; opacity: .85; filter: drop-shadow(0 6px 10px rgba(0,0,0,.35)); }
    .dpad button { width: 52px; height: 52px; border-radius: 14px; background: rgba(15,23,42,.8); border: 1px solid rgba(148,163,184,.38); cursor: pointer }
    .dpad button:active { transform: translateY(1px) }
    .dpad .empty { visibility: hidden }

    .footer { color: var(--muted); font-size: 12px; text-align: center; margin-top: 6px; }
    .kbd { display: inline-block; background: rgba(15,23,42,.6); border: 1px solid rgba(148,163,184,.4); padding: 2px 6px; border-radius: 6px; font-weight: 700; }
  </style>
</head>
<body>
  <div class="game-wrap">
    <div class="panel board" id="board" aria-label="Snake game board" role="application">
      <canvas id="game" width="600" height="600"></canvas>
      <div class="overlay" id="overlay" aria-live="polite">
        <div class="card" id="overlayCard">
          <h2>Neon Snake</h2>
          <p id="overlayText">Press <span class="kbd">Space</span> or tap <strong>Start</strong> to play.</p>
          <div class="row" style="justify-content:center">
            <button class="btn" id="btnStart">Start</button>
            <button class="btn secondary" id="btnResume" style="display:none">Resume</button>
            <button class="btn danger" id="btnRestart" style="display:none">Restart</button>
          </div>
        </div>
      </div>
      <div class="dpad" aria-hidden="true">
        <button data-dir="up">▲</button>
        <button class="empty"></button>
        <button data-dir="right">►</button>
        <button data-dir="left">◄</button>
        <button data-dir="down">▼</button>
        <button class="empty"></button>
      </div>
    </div>

    <div class="panel">
      <div class="hud">
        <div class="title">
          <span class="badge">HTML • CSS • JS</span>
          <span>Neon Snake</span>
        </div>
        <div class="stat" aria-live="polite"><span class="label">Score</span><span class="value" id="score">0</span></div>
        <div class="stat" aria-live="polite"><span class="label">High Score</span><span class="value" id="hiscore">0</span></div>
      </div>
      <div class="controls">
        <div class="row">
          <button class="btn" id="btnPause">Pause (P)</button>
          <button class="btn secondary" id="btnHardDrop">Nudge (N)</button>
          <button class="btn danger" id="btnResetHi">Reset High Score</button>
        </div>

        <div class="settings">
          <div class="group">
            <label>Speed</label>
            <div class="inline">
              <input id="speed" type="range" min="4" max="20" value="10" />
              <span id="speedLabel">10</span>
            </div>
          </div>
          <div class="group">
            <label>Grid Size</label>
            <div class="inline">
              <select id="grid">
                <option>10</option>
                <option>12</option>
                <option selected>16</option>
                <option>20</option>
                <option>24</option>
                <option>30</option>
              </select>
              <span class="label">Cells per side</span>
            </div>
          </div>
          <div class="group">
            <label>Rules</label>
            <div class="inline select">
              <label class="toggle"><input id="wrap" type="checkbox" checked /> Wrap walls</label>
              <label class="toggle"><input id="warpFood" type="checkbox" checked /> Warp food</label>
            </div>
          </div>
        </div>
        <div class="footer">
          Controls: <span class="kbd">←</span><span class="kbd">→</span><span class="kbd">↑</span><span class="kbd">↓</span> or <span class="kbd">WASD</span> • Pause <span class="kbd">P</span> • Start <span class="kbd">Space</span> • Nudge <span class="kbd">N</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --- Utility helpers ---
    const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
    const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));

    // --- Game state ---
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const overlayText = document.getElementById('overlayText');
    const btnStart = document.getElementById('btnStart');
    const btnResume = document.getElementById('btnResume');
    const btnRestart = document.getElementById('btnRestart');
    const btnPause = document.getElementById('btnPause');
    const btnHardDrop = document.getElementById('btnHardDrop');
    const btnResetHi = document.getElementById('btnResetHi');
    const scoreEl = document.getElementById('score');
    const hiEl = document.getElementById('hiscore');
    const speedEl = document.getElementById('speed');
    const speedLabel = document.getElementById('speedLabel');
    const gridEl = document.getElementById('grid');
    const wrapEl = document.getElementById('wrap');
    const warpFoodEl = document.getElementById('warpFood');

    let grid = 16; // cells per side
    let cellPx = canvas.width / grid; // pixel per cell
    let speed = 10; // ticks per second
    let wrapWalls = true;
    let warpFood = true;

    const saveKey = 'neon-snake-hiscore-v1';
    let hiScore = Number(localStorage.getItem(saveKey)) || 0;
    hiEl.textContent = hiScore;

    let snake, dir, nextDir, food, growing, score, time, acc, running, paused, ended;

    function resetGame() {
      grid = parseInt(gridEl.value, 10);
      speed = parseInt(speedEl.value, 10);
      wrapWalls = wrapEl.checked;
      warpFood = warpFoodEl.checked;
      cellPx = canvas.width / grid;

      const start = { x: Math.floor(grid/2), y: Math.floor(grid/2) };
      snake = [ {x:start.x, y:start.y}, {x:start.x-1, y:start.y}, {x:start.x-2, y:start.y} ];
      dir = {x:1, y:0};
      nextDir = {x:1, y:0};
      food = spawnFood();
      growing = 0;
      score = 0;
      time = 0; acc = 0;
      running = false; paused = false; ended = false;
      updateScore(0);
      draw();
    }

    function updateScore(delta) {
      score = Math.max(0, score + delta);
      scoreEl.textContent = score;
      if (score > hiScore) { hiScore = score; localStorage.setItem(saveKey, hiScore); hiEl.textContent = hiScore; }
    }

    function spawnFood() {
      let p;
      const maxAttempts = 1000;
      let attempts = 0;
      do {
        p = { x: randInt(0, grid-1), y: randInt(0, grid-1) };
        if (warpFood && Math.random() < .08) {
          // special: moving food spawns off-grid and will drift in
          p.vx = Math.random() < .5 ? -1 : 1;
          p.vy = Math.random() < .5 ? -1 : 1;
          p.x = p.vx < 0 ? grid : -1;
          p.y = p.vy < 0 ? grid : -1;
          p.moving = true;
        }
        attempts++;
        if (attempts > maxAttempts) break;
      } while (snake.some(s => s.x === p.x && s.y === p.y));
      return p;
    }

    function queueDir(nx, ny) {
      if (ended) return;
      // prevent reversing directly
      if ((nx === -dir.x && ny === -dir.y) || (nx === dir.x && ny === dir.y)) return;
      nextDir = { x: nx, y: ny };
    }

    function tick(dt) {
      acc += dt;
      const step = 1 / speed; // seconds per move
      while (acc >= step) {
        acc -= step;
        stepForward();
      }
    }

    function stepForward() {
      dir = nextDir; // commit latest direction once per tick

      // Move head
      let nx = snake[0].x + dir.x;
      let ny = snake[0].y + dir.y;

      if (wrapWalls) {
        nx = (nx + grid) % grid;
        ny = (ny + grid) % grid;
      } else {
        if (nx < 0 || ny < 0 || nx >= grid || ny >= grid) return gameOver();
      }

      // Self collision
      if (snake.some(s => s.x === nx && s.y === ny)) {
        return gameOver();
      }

      snake.unshift({ x: nx, y: ny });

      // Food logic
      if (Math.round(food.x) === nx && Math.round(food.y) === ny) {
        growing += 2; // grow by 2 segments
        updateScore(10);
        // slightly increase speed with score (cap)
        speed = clamp(speed + 0.05, 4, 22);
        food = spawnFood();
      }

      if (growing > 0) {
        growing--;
      } else {
        snake.pop();
      }

      // drift moving food in fractional space
      if (food.moving) {
        food.x += 0.2 * food.vx; // 5 ticks to move a cell
        food.y += 0.2 * food.vy;
        // once inside bounds, snap to grid and stop moving
        if (food.x >= 0 && food.y >= 0 && food.x < grid && food.y < grid) {
          food.x = Math.round(food.x); food.y = Math.round(food.y); food.moving = false;
        }
      }
    }

    function draw() {
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);

      // subtle grid glow
      const cell = w / grid;
      ctx.save();
      ctx.globalAlpha = .06;
      ctx.fillStyle = '#22d3ee';
      for (let i=0;i<grid;i++) {
        for (let j=0;j<grid;j++) {
          ctx.fillRect(i*cell+0.5, j*cell+0.5, cell-1, cell-1);
        }
      }
      ctx.restore();

      // Food
      const fx = (Math.round(food.x) + 0.5) * cell;
      const fy = (Math.round(food.y) + 0.5) * cell;
      const r = cell * 0.32;
      const grad = ctx.createRadialGradient(fx, fy, r*0.2, fx, fy, r);
      grad.addColorStop(0, 'rgba(167,139,250,1)');
      grad.addColorStop(1, 'rgba(34,211,238,.1)');
      ctx.beginPath();
      ctx.fillStyle = grad;
      ctx.arc(fx, fy, r, 0, Math.PI*2);
      ctx.fill();

      // Snake
      for (let i=snake.length-1; i>=0; i--) {
        const s = snake[i];
        const x = s.x * cell, y = s.y * cell;
        const t = i / Math.max(1, snake.length-1);
        const hue = 180 + t * 120; // cyan -> violet
        ctx.fillStyle = `hsl(${hue} 90% 60% / 1)`;
        ctx.shadowColor = `hsl(${hue} 100% 60% / .8)`;
        ctx.shadowBlur = 16;
        roundRect(ctx, x+2, y+2, cell-4, cell-4, 8, true);
      }

      // Head sparkle
      const head = snake[0];
      ctx.shadowBlur = 0;
      ctx.strokeStyle = 'rgba(255,255,255,.35)';
      ctx.lineWidth = 2;
      ctx.strokeRect(head.x*cell+3, head.y*cell+3, cell-6, cell-6);
    }

    function roundRect(ctx, x, y, w, h, r, fill) {
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      if (fill) ctx.fill(); else ctx.stroke();
    }

    // --- Main loop ---
    let rafId, last;
    function loop(ts) {
      if (!running || paused) { return; }
      if (!last) last = ts; const dt = (ts - last) / 1000; last = ts;
      tick(dt);
      draw();
      rafId = requestAnimationFrame(loop);
    }

    function start() {
      if (ended) resetGame();
      running = true; paused = false; overlay.classList.remove('show');
      last = undefined; // reset timer
      rafId = requestAnimationFrame(loop);
    }

    function pauseToggle() {
      if (!running) return;
      paused = !paused;
      if (paused) {
        overlay.classList.add('show');
        overlayText.innerHTML = 'Paused. Press <span class="kbd">P</span> or Resume to continue.';
        btnResume.style.display = '';
        btnStart.style.display = 'none';
        btnRestart.style.display = '';
      } else {
        overlay.classList.remove('show');
        last = undefined; // avoid jump after pause
        requestAnimationFrame(loop);
      }
    }

    function gameOver() {
      ended = true; running = false;
      overlay.classList.add('show');
      overlayText.textContent = `Game over! Score ${score}. Press Space or Restart.`;
      btnStart.style.display = 'none';
      btnResume.style.display = 'none';
      btnRestart.style.display = '';
    }

    // --- Resize handling: scale canvas to fit panel while keeping logical pixels independent ---
    function resizeCanvas() {
      const rect = document.getElementById('board').getBoundingClientRect();
      const size = Math.floor(Math.min(rect.width, rect.height));
      // Keep internal buffer reasonably high for crispness without being huge
      const deviceScale = Math.min(window.devicePixelRatio || 1, 2);
      canvas.width = Math.floor(size * deviceScale);
      canvas.height = Math.floor(size * deviceScale);
      cellPx = canvas.width / grid;
      draw();
    }

    window.addEventListener('resize', resizeCanvas);

    // --- Inputs ---
    window.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();
      if (k === ' ' && !running) { e.preventDefault(); start(); return; }
      if (k === 'p') { e.preventDefault(); pauseToggle(); return; }
      if (k === 'n') { nudge(); }
      if (k === 'r') { resetGame(); start(); }
      if (['arrowup','w'].includes(k)) { e.preventDefault(); queueDir(0,-1); }
      if (['arrowdown','s'].includes(k)) { e.preventDefault(); queueDir(0,1); }
      if (['arrowleft','a'].includes(k)) { e.preventDefault(); queueDir(-1,0); }
      if (['arrowright','d'].includes(k)) { e.preventDefault(); queueDir(1,0); }
    });

    document.querySelectorAll('.dpad [data-dir]').forEach(btn => {
      btn.addEventListener('pointerdown', () => {
        const d = btn.getAttribute('data-dir');
        if (d === 'up') queueDir(0,-1);
        if (d === 'down') queueDir(0,1);
        if (d === 'left') queueDir(-1,0);
        if (d === 'right') queueDir(1,0);
      });
    });

    canvas.addEventListener('pointerdown', handleSwipeStart, {passive:true});
    canvas.addEventListener('pointermove', handleSwipeMove, {passive:true});
    canvas.addEventListener('pointerup', handleSwipeEnd, {passive:true});
    let swipeStart = null;
    function handleSwipeStart(e){ swipeStart = {x: e.clientX, y: e.clientY}; }
    function handleSwipeMove(e){ /* no-op: we only evaluate on end */ }
    function handleSwipeEnd(e){
      if (!swipeStart) return; const dx = e.clientX - swipeStart.x; const dy = e.clientY - swipeStart.y; swipeStart = null;
      if (Math.hypot(dx,dy) < 20) return; // ignore tiny swipes
      if (Math.abs(dx) > Math.abs(dy)) { queueDir(Math.sign(dx), 0); } else { queueDir(0, Math.sign(dy)); }
    }

    // --- Buttons & settings ---
    btnStart.addEventListener('click', () => start());
    btnResume.addEventListener('click', () => { paused = false; overlay.classList.remove('show'); requestAnimationFrame(loop); });
    btnRestart.addEventListener('click', () => { resetGame(); start(); });
    btnPause.addEventListener('click', pauseToggle);
    btnHardDrop.addEventListener('click', nudge);
    btnResetHi.addEventListener('click', () => { localStorage.removeItem(saveKey); hiScore = 0; hiEl.textContent = '0'; });

    speedEl.addEventListener('input', () => { speed = parseInt(speedEl.value,10); speedLabel.textContent = speed; });
    gridEl.addEventListener('change', () => { const wasRunning = running; resetGame(); if (wasRunning) start(); });
    wrapEl.addEventListener('change', () => { wrapWalls = wrapEl.checked; });
    warpFoodEl.addEventListener('change', () => { warpFood = warpFoodEl.checked; });

    // --- Nudge (hard drop) --- 
    // Moves snake forward until it hits something or goes off-screen
    function nudge() {
      if (!running || paused || ended) return;
      let steps = 0;
      const originalSpeed = speed;
      speed = 60; // Temporarily max speed
      while (running && !ended) {
        stepForward();
        steps++;
        if (steps > grid * grid) break; // Prevent infinite loop in edge cases
      }
      speed = originalSpeed; // Restore original speed
      draw();
    }

    // Init
    resetGame();
    resizeCanvas();
  </script>
</body>
</html>